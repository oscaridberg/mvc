<h2>Kmom 02</h2>

<p>Från kursen oopython sitter mycket av de objektorienterade principerna kvar i närminnet och mycket av det som vi har gått igenom i denna kurs känner man igen. Många av de begrepp som har förekommit i kursen förklarar nästan sig själva genom att bara läsa ordet. Arv är att en klass ärver från en annan klass. Som ett exempel så kan ta en klass som representerar en bil som innehåller alla grundläggande metoder och attribut för att en bil ska fungera som tänkt. Vill man då skapa en mer specifik version av klassen, som till exempel en lastbil, så kan lastbilen ärva bilklassen och man slipper således skriva om de generella metoderna igen så som att köra frammåt eller att backa. Begreppet komposition är att en klass refererar till andra klasser och dess metoder, men varje enskild klass kan existera utan den andra. Även denna aspekt kan förklaras med hjälp av bilklassen, bilen har en motor men en bilmotor kan existera även om den inte tillhör en bil.</p>

<p>PHP stödjer att en barnklass kan endast ärva från en förälderklass, som kan ställa till det för en som utvecklare om man vill ärva metoder och attribut från flera klasser. "Traits" är en lösning på detta som tillåter en att skriva generella metoder utanför klassen, och som sedan flera klasser kan använda sig utav.</p>

<p>Interfaces påminner till stor del om hur traits fungarar. Man skapar först en generell klass, så som bilklassen som innehåller ett antal metoder, sedan kan man skapa olika klasser för bilmodeller som implementerar bilklassens metoder. Funktionaliteten för metoderna kan ändras i varje implementation. Som ett exempel har bilklassen metoden <em>drive_forward()</em> men för varje implementation ändras topphastigheten för varje bilmodell, så att en bil kan köra i 50km/h, en i 70km/h, en i 90km/h, och så vidare. Detta gör det möjligt att man kan loopa igenom samma metod i ett antal bilobjekt, även om de utför olika saker.</p>

<p>Nu när jag är klar med detta kursmoment så upplever jag att jag har uppnått en god struktur på mina kort-relaterade klasser, som gör det möjligt för mig att bygga vidare på dessa för att skapa mer komplex funktionalitet i nästkommande kursmoment. Som koden är strukturerad just nu skapas först ett "game" objekt som kan hålla ett antal spelarobjekt, var spelare kan sedan ha ett spelhandsobjekt som håller i kortobjekten. Skulle man vilja implemetera ett spel som till exempel blackjack kan det vara bra att ändra koden så att varje spelare kan ha mer än en hand, men för detta moment får en hand räcka tillsvidare. Nu när funktionaliteten som ska implementeras för detta moment är relativt enkel så känns kanske strukturen onödigt komplex, istället för att ha spelare och spelarhand som separata objekt hade det kunnat vara ett och samma objekt, men jag tror jag kommer till att ha nytta av den här modulariteten framöver. </p>

<p>Kortleken fungerar även den väl och det gick smidigt att arbeta med arv för att kunna skapa en kortlek som även innehöll två jokrar. Jag stötte dock på problem när jag först skulle implemetera kortleken, jag försökte mig på något alldeles för avancerat för ändamålet som gjorde klassen svår att arbeta med och jag har nu valt att använda ett enklare tillvägagångsätt som fungerar mycket bättre. Tanken var först att kortleken skulle vara en array som sedan i sig innehöll fyra arrayer, en för varje färg, där varje färg i sin tur innehöll korten från ess till kung. Det fungerade väl för att skapa en kortlek och att rendera den på webbsidan, men det gjorde oerhört svårt när det kom till att blanda kortleken. Kort sagt försökte jag mig på att skapa något onödigt komplicerat när det hade varit bäst att köra på det enklaste sättet först. Det är nog lätt hänt att man ibland tänker till för mycket och att desto mer man lär sig om programmering desto mer större konstruktioner försöker man sig på, när man egentligen kanske ska fokusera mer på vad som blir den enklaste implementationen av ens kod.</p>

<p>Något som jag har med mig från den förra kursen oopython och som även kommer till god anvädning i denna kurs är just att planera sin kod innan man börjar arbeta med den. Psuedokod är ett bra sätt att försöka förklara för sig själv hur man vill att ens kod ska fungera, och att rita upp en diagram gör det enklare för en att visualisera hur allt hänger ihop. Börjar man direkt med att skriva koden är det lätt hänt att man ritar in sig i ett hörn som kan vara svårt att ta sig ut ur, eller att att logiken i programmet inte blir som man har tänkt sig. Diagrammen behöver inte nödväntigtvis följa alla regler som finns etablerade eller vara ritade snyggt i ett program, utan många gånger kan jag känna att det räcker att rita upp det på en bit papper så att man får en god överblick av hur man vill att ens kod ska fungera. </p>

<p>Avslutningsvis får min TIL för detta kursmoment bli att det enklaste lösningen förmodligen även är den bästa lösningen för ett problem, man vinner nödväntigtvis ingenting på att krångla till saker i onödan. En ytterligare aspekt får även vara att desto bättre planering man gör desto enklare gör man det för sig vid ett senare stadie i utvecklingen.</p>
